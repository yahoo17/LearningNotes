类具有属性成员和方法成员



类可分三个部分表达



如图所示



类名、类的属性成员和类的方法成员



属性是数据的抽象



操作是以某种方式操纵数据的过程抽象



类封装了属性和操作



实现信息隐藏



如图所示



也就是说，属性只能通过类的方法进行访问



对象是类的实例



对象继承了类的所有属性和方法



类是对象的模板，如图所示



类刻画了对象的本质



刻画了一组对象



所共有的属性和方法



继承是传统系统和面向对象系统的



关键区分因素之一



子类继承超类的所有属性和操作



这意味着



所有原本针对超类设计和实现的



数据结构和算法



对子类是立即可用的



不需要进一步的工作，从而实现复用

如图所示



从面向对象的观点来看



你现在正在坐的椅子chair



是某个称为家具furniture



的更大的对象类的一个实例



一组类属性可以和家具类中的每个对象关联



例如，所有家具在其很多可能的属性中



有价格、尺寸、重量、位置和颜色等



无论我们谈论的是桌子还是椅子



这些属性总是可用的



因为椅子和桌子都是家具类的实例



继承了该类定义的所有属性



如图所示



类可以通过描述类的属性来定义



也可以通过描述类的方法来定义



在家具furniture类中的每个对象都可以



以一系列不同的方式被操纵



他可以被买或卖



或被称重或者被从一个位置移动到另外一个位置



这些操作operation



也被称为服务service



或者方法method



将修改对象的一个或者多个属性



前面关于家具对象类型的定义



隐含了类层次的存在，如图所示



在类层次中



超类的属性和操作被子类继承



子类可以加入自己私有的属性和方法



家具类的层次如图所示



家具类包含了四个子类实例



每个子类还可以定义为更具体的实例



对包含在超类中的数据或操作的任意变化



立即被继承该超类的所有子类继承



因此，类层次变成了一种机制



通过它，在高层的变化



立即传播到系统的其它部分



需要注意的是



在类层次的每个层上



新的属性和操作



可以被加到那些



从类层次中的高层



继承来的属性和操作中



这种现象通常称之为重载（overide）



这样就会产生一种新的现象



同一个方法名



在不同的对象下



表现的行为语义



不一样



面向对象领域将这种现象称为 多态



多态使得程序



在获得软件复用的同时



能获得应对变更的某种灵活性



在上述描述中



通过继承可以实现软件复用



继承显然在某种程度上牺牲了封装性



从这点来看，封装与继承



在某种程度上是矛盾的