 作者：守望者1028
链接：https://www.nowcoder.com/discuss/55353?type=2&order=0&pos=26&page=7
来源：牛客网

1语言基础（C++）

析构函数可以抛出异常吗?

 C++标准指明析构函数不能、也不应该抛出异常 

 **C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象**(也即对象超出了它原来的作用域)，**并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务**，所以从这个意义上说，**析构函数已经变成了异常处理的一部分** 

 （1）    指针和引用的区别

>
>
>指针-对于一个类型T，T*就是指向T的指针类型，也即一个T*类型的变量能够保存一个T对象的地址，而类型T是可以加一些限定词的，如const、volatile等等。见下图，所示指针的含义：
>
>
>
>引用-引用是一个对象的别名，主要用于函数参数和返回值类型，符号X&表示X类型的引用。

 （2）    堆和栈的区别
 （3）    new和delete是如何实现的，new 与 malloc的异同处

>
>
> **new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。** 
>
> **delete复杂数据类型先调用析构函数再调用operator delete。** 
>
>new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小，最后调用三次构造函数。
>
>实际分配的内存块如下：
>
> ![img](https://img-blog.csdn.net/20140901013652954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGFzc2lvbl93dTEyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 
>
>这里为什么要写入数组大小呢？因为对象析构时不得不用这个值，举个例子：
>
> **针对复杂类型，new[]会额外存储数组大小。** 
>
> **针对简单类型，delete和delete[]等同** 
>
>复杂数据类型（需要由析构函数销毁对象）
>
>释放内存之前会先调用每个对象的析构函数。
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190415134656597.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQxMTMyMQ==,size_16,color_FFFFFF,t_70) 
>
>new[]分配的内存只能由delete[]释放。
>
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190415134729617.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQxMTMyMQ==,size_16,color_FFFFFF,t_70) 

 （4）    C和C++的区别
 （5）    C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）
 （6）    Struct和class的区别
 （7）    define 和const的区别（编译阶段、安全性、内存占用等）

> 角度1： 
> 就定义常量说的话： 
> const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型。 
>
> 角度2： 
> 就起作用的阶段而言： 
> define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。 
>
> 角度3： 
> 就起作用的方式而言： 
> define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。  
>
>角度4： 
> 就空间占用而言： 
> 例如：
>
>```
>#define PI 3.14     //预处理后 占用代码段空间
>const float PI=3.14;    //本质上还是一个 float，占用数据段空间
>```
>
> 角度5： 
> 从代码调试的方便程度而言： 
> const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了 
>
>





 （8）    在C++中const和static的用法（定义，用途）

>static关键字的作用：
>
>1、函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此，其值在下次调用的时候仍然维持原始值。
>
>2、在模块内的static全局变量可以被模块内的所有函数访问，但是不能被模块外的其他函数访问。
>
>3、在模块内的static函数只可以被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内。
>
>4、在类中的static成员变量属于整个类所有，对类的所有对象只有一份拷贝。
>
>5、**static修饰成员函数**: static修饰的成员函数属于类，不属于对象，只有一 份。静态成员函数的主要目的是为了处理静态数据成员。可以通过对象或者类名来调用静态成员函数。 静态成员函数没有this指针，所以不能直接访问非静态成员函数，但是可以直接访问静态成员函数。非静态成员函数可以直接访问静态成员函数，因为静态成员函数属于类。如果想在静态成员函数内访问非静态成员函数，可以将this指针显示传 递给静态成员函数
>
>**static修饰变量**: static修饰局部变量，会改变局部变量的生命周期， 但是不改变作用域。static修饰的全局变量，会对全局变量进行内部链接 指定，即全局变量只能在本文件中使用。 static修饰的变量存放在数据段，但是初始值若为0则放在BSS节中，而初始值非零则放在数据节中。数据节和BSS节都属于数据段。（BSS段通常是指用来存放程序中未初始化的全局变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0）。
>
> **static修饰成员变量**:          static修饰的成员变量属于类，不属于对象，只有一 份，必须在类外单独进行初始化。使用的时候可以通过对象名或 类名引用，它只在类域内有效。如果一个成员变量同时被const和 static修饰，则直接可以在声明的时候进行赋值。 
>
>
>
>
>const关键字的作用：
>
>1、想要阻止一个变量被改变，可以使用const关键字。在定义该const关键字是，通常要对它进行初始化，因为以后再也没有机会去改变它。
>
>2、对于指针来说，可以指定指针本省为const，也可以指定指针所指向的数据为const，或者二者同时指定为const。
>
>3、在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值。
>
>4、对于类的成员函数，若指定为const，则表明其实一个常函数，不能修改类的成员变量。
>
>5、对于类的成员函数，有时候必须制定其返回值为const，以使得其返回值不能为左值。
>

 （9）    const和static在类中使用的注意事项（定义、初始化和使用）
 （10）    C++中的const类成员函数（用法和意义）
 （11）    计算下面几个类的大小：
 class A {};: sizeof(A) = 1;
 class A { virtual Fun(){} };: sizeof(A) = 4(32位机器)/8(64位机器);
 class A { static int a; };: sizeof(A) = 1;
 class A { int a; };: sizeof(A) = 4;
 class A { static int a; int b; };: sizeof(A) = 4;
 （12）    给一个代码，求输出结果
 class A
 {
 public:
 A(int x){}
 }
 问：A a = 1;是否正确, 如果正确, 那么它调用了哪些函数？
 这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，栗子很多，不多说了）
 （13）    C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等
 （14）    STL源码中的hash表的实现
 （15）    STL中unordered_map和map的区别
 （16）    STL中vector的实现
 （17）    vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。
 （18）    C++中的重载和重写的区别：
 （19）    C ++内存管理（热门问题）
 （20）    介绍面向对象的三大特性，并且举例说明每一个。
 （21）    多态的实现（和下个问题一起回答）
 （22）    C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）

>
>
>https://blog.csdn.net/li1914309758/article/details/79916414

> base1_1前面多了一个变量 __vfptr(常说的虚函数表vtable指针), 其类型为void**,  这说明它是一个void*指针(**注意:**不是数组). 
> 它被定义成一个指向指针数组的指针, 而不是直接定义成一个指针数组呢? 
>
> 属于类对象的, 仅是一个指向**虚函数表的一个指针__vfptr**而已, 
>
>> ![img](https://img-blog.csdn.net/20180710202321318?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMTkxNDMwOTc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
>>
>>通过Watch 1窗口我们看到: 
>>
>>1. b1和b2是类的两个变量, 理所当然, 她们的地址是不同的(见 &b1 和 &b2)
>>2. 虽然b1和b2是类的两个变量, 但是: 她们的__vfptr的指向却是同一个虚函数表
>>
>> 同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表. 
>>
>> ![img](https://img-blog.csdn.net/20180710202345735?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMTkxNDMwOTc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

 >至于函数调用, 我想, 不用说大家应该知道了:
 >
 >1. 如果不是虚函数, 直接调用指针对应的基本类的那个函数
 >2. 如果是虚函数, 则查找虚函数表, 并进行后续的调用. 虚函数表在定义一个时, 编译器就为我们创建好了的. 所有的, 同一个类, 共用同一份虚函数表.

>
>
>基类有虚函数
>
>子类也有虚函数 子类的虚函数跟在基类后面, 子类完全不知道自己虚函数表后面还有虚函数
>
> Derive1的虚函数表依然是保存到第1个拥有虚函数表的那个基类的后面的. 

>
>
> 虚函数会存在效率的问题，如果是普通函数，那么在编译时期，其相对地址是确定的；但如果是虚函数，它执行过程中会跳转两次（首先找到对象的虚函数表，其次通过该虚函数表中存的虚函数地址找到真正的执行地址），这样CPU运行的时候会跳转两次，而普通函数只跳一次。CPU每跳转一次，预取指令基本上就要作废很多，cache命中率低。所以效率会很低。换而言之，就是虚函数的地址是动态的，譬如取到的地址在eax里，则在call eax之后的那些已经被预取进入流水线的所有指令都将失效，产生大量气泡。流水线越长，一次分支预测失败的代价也就越大。 
>
> 另外，第二点编译器不好优化。因为编译器只知道调用的是一个不确定的地址处的函数，没法知道更多细节，也就没法替你做更多优化。 

（23）    实现编译器处理虚函数表应该如何处理
 （24）    析构函数一般写成虚函数的原因

 在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。 

 （25）    构造函数为什么一般不定义为虚函数

 虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。 要创建一个对象，你需要知道对象的完整信息。 特别是，你需要知道你想要创建的确切类型。 因此，构造函数不应该被定义为虚函数。 

 （26）    构造函数或者析构函数中调用虚函数会怎样

 **简单的说就是，在子类对象的基类子对象构造期间，调用的虚函数的版本是基类的而不是子类的。**  （27）    纯虚函数
 （28）    静态绑定和动态绑定的介绍

静态类型：对象在声明时采用的类型，在编译期既已确定；

动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；

静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；

动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

动态绑定的原理: 当编译器发现类中有虚函数的时候，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中增加一个指针：vpointer，这个指针是指向对象的虚函数表。在多态调用的时候，根据vpointer指针，找到虚函数表来实现动态绑定。 

![1587196048780](1语言基础（C++）.assets/1587196048780.png)

 ![1587196064215](1语言基础（C++）.assets/1587196064215.png)



（29）    引用是否能实现动态绑定，为什么引用可以实现

 指针或引用是在运行期根据他们绑定的具体对象确定 

 （30）    深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）

```
深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。
```

假设B复制了A，修改A的时候，看B是否发生变化：

如果B跟着**也变了**，说明是浅拷贝，拿人手短！（修改堆内存中的同一个值）

如果B**没有改变**，说明是深拷贝，自食其力！（修改堆内存中的不同的值）

 （31）    对象复用的了解，零拷贝的了解

 对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。 

 零拷贝：零拷贝主要的任务就是避免CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效 

 如用户空间到内核空间的拷贝，这个是没有必要的，我们可以采用零拷贝技术，这个技术就是通过mmap，直接将内核空间的数据通过映射的方法映射到用户空间上，即物理上共用这段数据。 

 （32）    介绍C++所有的构造函数

 **最基本的构造函数** 

```
		Base(int var) : m_Var(var)
 5     {
 6     }
 	1）传参   2）给类数据成员开辟空间     3）执行冒号语法给数据成员初始化    4）执行构造函数括号里面的内容


```

 **拷贝构造函数** 

 ```
7     //拷贝构造函数
 8     Base(Base &ref) : m_Var(ref.m_Var)
 9     {
10     }
 ```



**普通派生类构造函数的写法**

定义派生类对象的时候，会按如下步骤执行构造操作：

1）传参     2）根据继承时的声明顺序构造基类    3）给类数据成员开辟空间    4）执行冒号语法后面的语句    5）执行构造函数函数体语句

```
 1 class Base1
 2 {
 3 public:
 4     Base1(int b1) : m_b1(b1)
 5     {
 6     }
 7 private:
 8     int m_b1;
 9 };
10 
11 class Base2
12 {
13 public:
14     Base2(int b2) : m_b2(b2)
15     {
16     }
17 private:
18     int m_b2;
19 };
20 
21 class Derived : public Base1, public Base2
22 {
23 public:
24     Derived(int b1, int b2, int d) : Base1(b1), Base2(b2), m_d(d)
25     { //注意冒号语法后面的顺序无所谓，创造基类是按照上面的继承声明顺序来进行的...
26     }
27 private:
28     int m_d;
29 };
```

 **含有虚继承的派生类构造函数的写法** 

 当最远的派生类Derived创建了基类Base之后，其直接基类创建Base类的语句将会被忽略掉。 

```
class B
{
}
class B1:virtual public B
{
}
class B2:virtual public B
{
}
class D:public B1,public B2
{
}
```

由D直接创建B

 （33）    什么情况下会调用拷贝构造函数（三种情况）

1.用已有对象创建新的对象

2.把对象当成参数传进去,值传递,不是传递引用

3.返回一个对象或者对象的引用

 （34）    结构体内存对齐方式和为什么要进行内存对齐？

 结构体不像数组，结构体中可以存放不同类型的数据，它的大小也不是简单的各个数据成员大小之和，限于读取内存的要求，而是每个成员在内存中的存储都要按照一定偏移量来存储，根据类型的不同，每个成员都要按照一定的对齐数进行对齐存储，最后整个结构体的大小也要按照一定的对齐数进行对齐。 

> 第一个成员在与结构体变量偏移量为0的地址
> 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
> 对齐数=min(编译器默认的一个对齐数,该成员大小)
> linux 中默认为4
> vs 中的默认值为8
> 结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）

CPU处理效率高 其实结构体内存对齐是拿空间换取时间的做法。提高效率

 （35）    内存泄露的定义，如何检测与避免？

一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该 内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。

方法:



>1. 采用良好的一致的编程规范是防止内存问题第一道也是最重要的措施。 
>
>2. 静态检测 静态代码检测工具Cppcheck
>
>    ![这里写图片描述](https://img-blog.csdn.net/20180228142756433?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhczEwOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
>
>2. 动态运行检测  
>
>   Valgrind
>
>   valgrind 是帮助程序员寻找程序里的 bug 和改进程序性能的工具。程序通过 valgrind 运行时，valgrind 收集各种有用的信息，通过这些信息可以找到程序中潜在的 bug 和性能瓶颈。
>
>   Valgrind 现在提供多个工具，其中最重要的是 **Memcheck**，Cachegrind，Massif 和 Callgrind。Valgrind 是在 Linux 系统下开发应用程序时用于调试内存问题的工具。它尤其擅长发现内存管理的问题，它可以检查程序运行时的内存泄漏问题。其中的 memecheck 工具可以用来寻找 c、c++ 程序中内存管理的错误。可以检查出下列几种内存操作上的错误：
>
>   读写已经释放的内存
>
>   读写内存块越界（从前或者从后）
>
>   使用还未初始化的变量
>
>   将无意义的参数传递给系统调用
>
>   valgrind ./test

 （36）    手写实现智能指针类（34-37我没遇见过）

>#include <meomery>
>
> std::shared_ptr包装了new操作符动态分别的内存，可以自由拷贝复制，基本上是使用最多的一个智能指针类型 
>
> std::weak_ptr网上很多人说其实是为了解决std::shared_ptr在相互引用的情况下出现的问题而存在 与std::shared_ptr最大的差别是在赋值是，不会引起智能指针计数增加。 
>
>





 （37）    调试程序的方法

>
>
>gdb
>
>1.g++ -g test test.cpp
>
>2.gdb test

 （38）    遇到coredump要怎么调试

>
>
>gdb可以分析coredump

 （39）    内存检查工具的了解
 （40）    模板的用法与适用场景
 （41）    成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？

>
>
> 初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。因此，由于常量只能初始化不能赋值，所以常量成员必须使用初始化列表； 
>
> 对于内置类型，如int, float等，使用初始化类表和在构造函数体内初始化差别不是很大，但是对于类类型来说，最好使用初始化列表，为什么呢？使用初始化列表少了一次调用默认构造函数的过程，这对于数据密集型的类来说，是非常高效的。 
>
> 因为类类型的数据成员对象在进入函数体是已经构造完成，也就是说在成员初始化列表处进行构造对象的工作，这是调用一个构造函数，在进入函数体之后，进行的是 对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器提供的默认按成员赋值行为）

 （42）    用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）

> nullptr关键字及用法
>
> 

 [2.3、std::unordered_map](http://www.cnblogs.com/feng-sc/p/5710724.html#title23) 

> std::unordered_map与std::map用法基本差不多，但STL在内部实现上有很大不同，std::map使用的数据结构为二叉树，而std::unordered_map内部是哈希表的实现方式，哈希map理论上查找效率为O(1)。但在存储效率上，哈希map需要增加哈希表的内存开销。 

>　　std::unordered_set的数据存储结构也是哈希表的方式结构，除此之外，std::unordered_set在插入时不会自动排序，这都是std::set表现不同的地方。

（43）    C++的调用惯例（简单一点C++函数调用的压栈过程）
 （44）    C++的四种强制转换
 2计算机网络（TCP/IP）
 （1）    建立TCP服务器的各个系统调用
 （2）    继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？
 （3）    对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.
 （4）    路由协议所使用的算法。
 （5）    TCP和UDP的区别
 （6）    TCP和UDP相关的协议与端口号
 （7）    TCP（UDP，IP）等首部的认识（http请求报文构成）
 （8）    网页解析的过程与实现方法
 （9）  在浏览器中输入URL后执行的全部过程（如[www.baidu.com](http://www.baidu.com)）
 （10）    网络层分片的原因与具体实现
 （11）    TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）
 （12）    TCP握手以及每一次握手客户端和服务器端处于哪个状态（11种状态）
 （13）    为什么使用三次握手，两次握手可不可以？
 （14）    TIME_WAIT的意义（为什么要等于2MSL）
 （15）    超时重传机制（不太高频）
 （16）    TCP怎么保证可靠性（面向字节流，超时重传，应答机制，滑动窗口，拥塞控制，校验等）？
 （17）    流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？
 （18）    tcp滑动窗口协议
 （19）    拥塞控制和流量控制的区别
 （20）    TCP拥塞控制，算法名字？（极其重要）
 （21）    http协议与TCP联系
 （22）    http/1.0和http/1.1的区别
 （23）    http的请求方法有哪些？get和post的区别。
 （24）    http的状态码
 （25）    http和https的区别，由http升级为https需要做哪些操作
 （26）    https的具体实现，怎么确保安全性
 （27）    http中浏览器一个URL的流程，这个过程中浏览器做了什么，URL包括哪三个部分？
 （28）    一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？
 （29）    对称密码和非对称密码体系
 （30）    数字证书的了解（高频）
 （31）    客户端为什么信任第三方证书
 （32）    RSA加密算法，MD5原理（MD5不算加密算法）
 （33）    单条记录高并发访问的优化
 （34）    介绍一下ping的过程，分别用到了哪些协议
 （35）    TCP/IP的分片粘包过程
 （36）    有没有抓过TCP包，描述一下
 （37）    一个ip配置多个域名，靠什么识别？
 （38）    服务器攻击（DDos攻击）
 3数据库（MySQL）
 数据库我自身不是特别熟，面试的时候一般也都坦言了，所以面试官都只是问一些基础题目。
 （1）    关系型和非关系型数据库的区别（各自优点）
 （2）    常用SQL语句（DDL,DML,DCL,TCL）
 （3）    数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写
 （4）    数据库的索引类型
 （5）    聚集索引和非聚集索引的区别（叶节点存储内容）
 （6）    唯一性索引和主码索引的区别
 （7）    索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）
 （8）    索引的底层实现（B+树，为何不采用红黑树，B树）
 （9）    B树和B+树具体实现
 （10）    索引最左前缀问题
 （11）    Mysql的优化（高频，索引优化，性能优化）
 （12）    数据库引擎介绍，innodb和myisam的特点与区别
 （13）    数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）
 （14）    数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）
 （15）    数据库的隔离级别，mysql和Oracle的隔离级别分别是什么
 （16）    数据库连接池的作用
 （17）    Mysql的表空间方式，各自特点
 （18）    分布式事务
 （19）    数据库的范式
 （20）    数据的锁的种类，加锁的方式
 （21）    视图的作用与使用方法（如何删除等）
 （22）    分库分表，主从复制，读写分离。（我不会，也没碰到过）
 （23）    项目中哪里用到了数据库，怎么用的
 4Linux基础
 Linux这一块如果不太熟，可以直接说，但是因为开发岗位一般都是在Linux平台下的，所以几个基础问题还是要会的。
 （1）    Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）

>
>
>

 （2）    文件系统的理解（EXT4，XFS，BTRFS）
 （3）    文件处理grep,awk,sed这三个命令必知必会
 （4）    IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？
 （5）    Epoll的ET模式和LT模式（ET的非阻塞）
 （6）    查询进程占用CPU的命令（注意要了解到used，buf，***代表意义）
 （7）    linux的其他常见命令（kill，find，cp等等）
 （8）    shell脚本用法
 （9）    硬连接和软连接的区别
 （10）    文件权限怎么看（rwx）
 （11）    文件的三种时间（mtime, atime，ctime），分别在什么时候会改变
 （12）    Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令
 5操作系统
 （1）    进程与线程的区别和联系
 （2）    一个进程可以创建多少线程，和什么有关
 （3）    一个程序从开始运行到结束的完整过程（四个过程）
 （4）    进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）
 （5）    进程调度方法详细介绍
 （6）    页面置换方法详细介绍
 （7）    能否实现一个LRU算法
 （8）    死锁的必要条件（怎么检测死锁，解决死锁问题）
 （9）    哲学家就餐，银行家，读者写者，生产者消费者（怎么加锁解锁，伪代码）
 （10）    海量数据的bitmap使用原理
 （11）    布隆过滤器原理与优点
 （12）    布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题
 （13）    同步IO和异步IO
 （14）    文件读写使用的系统调用
 （15）    线程池的了解、优点、调度处理方式和保护任务队列的方式
 （16）    怎么回收线程
 （17）    僵尸进程问题
 （18）    多线程同步（尤其是如果项目中用到了多线程，很大可能会结合讨论）
 （19）    mem***了解
 （20）    异常和中断的区别
 （21）    一般情况下在Linux/windows平台下栈空间的大小
 6设计模式和算法
 设计模式一般都不会考太多，除非你明确说自己懂。我基本上就不涉及到设计模式的东西，所以只是简要说说。当然，单例模式和简单工厂模式的概念和使用场景还是要知道的。
 （1）    介绍熟悉的设计模式（单例，简单工厂模式）
 （2）    写单例模式（饿汉模式和懒汉模式），线程安全版本
 （3）    MVC设计模式
 算法这一块太过庞大，几乎都有可能，牛油们最好还是去刷剑指offer（level 1），leetcode（如果能够刷到最高难度，算法对你来说已经不是什么了，或者说面试对你来说简直就是吃饭喝水的难度），左神的书《程序源代码面试指南》（字符串，数组，dp，海量数据问题，搞定它们也就搞定面试的一半）。
 下面还是简单的列举一些吧（包括一些数据结构题目，只列举简单的，面试的算法一半不会太难，但是现在一般都是需要比较好的思维，或者曾经接触过这方面的题，建议就是多刷题，做题感觉是刷出来的）
 （1）    红黑树的了解（平衡树，二叉搜索树），使用场景
 （2）    红黑树在STL上的应用
 （3）    了解并查集吗？（低频）
 （4）    贪心算法和动态规划的区别
 （5）    判断一个链表是否有环，如何找到这个环的起点
 （6）    实现一个strcpy函数（或者memcpy），如果内存可能重叠呢
 （7）    实现一个循环队列
 （8）    排序算法（写快排，归并排序，堆排序），算法的时间复杂度，空间复杂度，是否稳定等
 （9）    快排存在的问题，如何优化
 （10）    反转一个链表
 （11）    Top K问题（可以采取的方法有哪些，各自优点？）
 （12）    Bitmap的使用，存储和插入方法
 （13）    二叉树的先序、中序、后序遍历（非递归实现）
 （14）    二叉树的公共祖先（简单地说，剑指offer上的题大都是高频题）
 （15）    1-n中有多少个1
 （16）    字典树的理解以及在统计上的应用
 （17）    数组的全排列
 （18）    N个骰子出现和为m的概率
 （19）    海量数据问题（可参考左神的书）
 （20）    一致性哈希
 7智力题
 我特别把智力题单独拿出来讲，是因为这一块其实有些公司很看重（例如腾讯），但是我基本上也没刷过这类题目，接触不多，牛油们自行补充吧。
 （1）    100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）
 （2）    毒药问题，n拼毒药，要快速找出哪一瓶有毒，需要几只小白鼠
 （3）    博弈论问题
 （4）    先手必胜策略问题：n本书，每次能够拿X-X本，怎么拿必胜
 （5）    放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。
 （6）    瓶子换饮料问题：多少个瓶子能够换1瓶饮料，问最多能喝几瓶  